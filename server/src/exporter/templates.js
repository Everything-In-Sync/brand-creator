import archiver from 'archiver';
import chroma from 'chroma-js';
import { PNG } from 'pngjs';

const TEXT_LIGHT = '#FFFFFF';
const TEXT_DARK = '#111827';

export function createPaletteJson(palette, meta) {
  return JSON.stringify(
    {
      exportedAt: new Date().toISOString(),
      sessionId: meta.sessionId,
      paletteIndex: meta.paletteIndex,
      input: meta.input,
      palette
    },
    null,
    2
  );
}

export function createTokensCss(palette) {
  const pairs = buildRoleTokenPairs(palette.roles);
  const lines = pairs.map(({ key, value }) => `  --brand-${key}: ${value};`);
  const darkLines = pairs.map(({ key, darkValue }) => `  --brand-${key}: ${darkValue};`);
  const css = [
    ':root {',
    ...lines,
    '}',
    '',
    ':root[data-theme="dark"], .theme-dark {',
    ...darkLines,
    '}'
  ].join('\n');
  return `${css}\n`;
}

export function createTokensScss(palette) {
  const pairs = buildRoleTokenPairs(palette.roles);
  const lines = pairs.map(({ key, value }) => `$brand-${key}: ${value};`);
  const darkLines = pairs.map(({ key, darkValue }) => `$brand-${key}-dark: ${darkValue};`);
  return [...lines, '', ...darkLines, ''].join('\n');
}

export function createTailwindSnippet(palette) {
  return `module.exports = {\n  theme: {\n    extend: {\n      colors: {\n        brand: {\n          primary: '${palette.roles.primary.hex}',\n          secondary: '${palette.roles.secondary.hex}',\n          accent: '${palette.roles.accent.hex}',\n          neutral: '${palette.roles.neutral.hex}',\n          background: '${palette.roles.background.hex}'\n        }\n      }\n    }\n  }\n};\n`;
}

export function createReadme(meta, palette) {
  const lines = [
    'Branding Package Generator Export',
    '=================================',
    '',
    `Palette: ${palette.name}`,
    `Generated: ${new Date().toISOString()}`,
    `Session: ${meta.sessionId}`,
    '',
    'Files in this archive:',
    '- palette.json: Structured palette data with metadata.',
    '- tokens.css: CSS custom properties with light and dark variants.',
    '- tokens.scss: SCSS variables mirroring the CSS tokens.',
    '- tailwind.config.snippet.js: Tailwind theme extension.',
    '- swatches.svg: Vector strip of labeled swatches.',
    '- swatches.png: Raster swatch strip sized 2000x300.',
    '- palette.gpl: GIMP palette for compatible tools.',
    '',
    'Usage guidelines:',
    '1. Import tokens.css or tokens.scss into your design system.',
    '2. Extend Tailwind using the provided snippet if applicable.',
    '3. Share swatches.svg/png with stakeholders for quick previews.',
    '4. palette.json can be fed back into the generator for auditing.',
    '',
    'Licensing notes:',
    '- Generated color values and tokens are original data, free for commercial use.',
    '- Google Fonts referenced remain under the Open Font License.',
    '',
    'Accessibility summary:',
    `- Primary contrast on text: ${palette.roles.primary.contrastOnText}:1`,
    `- Accent contrast on text: ${palette.roles.accent.contrastOnText}:1`,
    '- All role pairings meet or exceed WCAG 2.2 AA requirements.',
    '',
    'Determinism:',
    `- Re-run with seed ${meta.input.seed} for identical output.`,
    '',
    'Generated by Branding Package Generator.'
  ];
  return `${lines.join('\n')}\n`;
}

export function createSwatchesSvg(palette) {
  const width = 1000;
  const height = 240;
  const swatchWidth = width / 5;
  const roles = ['primary', 'secondary', 'accent', 'neutral', 'background'];
  const swatches = roles.map((role) => palette.roles[role]);

  const rects = swatches
    .map((swatch, index) => {
      const x = index * swatchWidth;
      const textColor = swatch.textOn === 'light' ? TEXT_LIGHT : TEXT_DARK;
      return `    <g transform="translate(${x},0)">\n      <rect width="${swatchWidth}" height="170" fill="${swatch.hex}" />\n      <text x="20" y="190" font-family="Inter, Arial, sans-serif" font-size="18" fill="${textColor}" font-weight="600">${roleLabel(roles[index])}</text>\n      <text x="20" y="215" font-family="Inter, Arial, sans-serif" font-size="14" fill="${textColor}">${swatch.hex}</text>\n    </g>`;
    })
    .join('\n');

  return `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">\n  <rect width="${width}" height="${height}" fill="#FFFFFF" />\n${rects}\n</svg>\n`;
}

export async function createSwatchesPng(palette) {
  const width = 2000;
  const height = 300;
  const swatchWidth = width / 5;
  const png = new PNG({ width, height });
  fillRect(png, 0, 0, width, height, hexToRgb('#FFFFFF'));

  const roles = ['primary', 'secondary', 'accent', 'neutral', 'background'];

  roles.forEach((role, index) => {
    const swatch = palette.roles[role];
    const x = Math.round(index * swatchWidth);
    fillRect(png, x, 0, Math.ceil(swatchWidth), 220, hexToRgb(swatch.hex));
    const textColor = swatch.textOn === 'light' ? hexToRgb(TEXT_LIGHT) : hexToRgb(TEXT_DARK);
    drawPixelText(png, roleLabel(role), x + 20, 240, textColor, 3);
    drawPixelText(png, swatch.hex.toUpperCase(), x + 20, 265, textColor, 3);
  });

  return packPng(png);
}

export function createGplPalette(palette) {
  const roles = ['primary', 'secondary', 'accent', 'neutral', 'background'];
  const lines = roles.map((role) => {
    const rgb = hexToRgb(palette.roles[role].hex);
    return `${rgb[0]} ${rgb[1]} ${rgb[2]}\t${roleLabel(role)}`;
  });
  return `GIMP Palette\nName: ${palette.name}\nColumns: 5\n#\n${lines.join('\n')}\n`;
}

export function buildZipStream(response, palette, meta) {
  const archive = archiver('zip', { zlib: { level: 9 } });
  archive.on('error', (err) => {
    throw err;
  });

  archive.append(createPaletteJson(palette, meta), { name: 'palette.json' });
  archive.append(createTokensCss(palette), { name: 'tokens.css' });
  archive.append(createTokensScss(palette), { name: 'tokens.scss' });
  archive.append(createTailwindSnippet(palette), { name: 'tailwind.config.snippet.js' });
  archive.append(createSwatchesSvg(palette), { name: 'swatches.svg' });

  archive.append(createReadme(meta, palette), { name: 'readme.txt' });

  createSwatchesPng(palette)
    .then((buffer) => {
      archive.append(buffer, { name: 'swatches.png' });
      archive.append(createGplPalette(palette), { name: 'palette.gpl' });
    })
    .catch((error) => {
      archive.append(`Failed to render PNG swatches: ${error.message}`, { name: 'swatches.txt' });
      archive.append(createGplPalette(palette), { name: 'palette.gpl' });
    })
    .finally(() => {
      archive.finalize();
    });

  archive.pipe(response);
  return archive;
}

function buildRoleTokenPairs(roles) {
  const entries = [];
  Object.entries(roles).forEach(([role, data]) => {
    entries.push({
      key: `${role}`,
      value: data.hex,
      darkValue: adjustForDark(data.hex)
    });
    entries.push({
      key: `${role}-rgb`,
      value: hexToRgb(data.hex).join(', '),
      darkValue: hexToRgb(adjustForDark(data.hex)).join(', ')
    });
    entries.push({
      key: `${role}-contrast`,
      value: contrastHex(data.textOn),
      darkValue: contrastHex(data.textOn === 'light' ? 'dark' : 'light')
    });
  });
  return entries;
}

function adjustForDark(hex) {
  const color = chroma(hex);
  const darkened = color.luminance() > 0.4 ? color.darken(1) : color.brighten(1.2);
  return darkened.hex();
}

function contrastHex(textOn) {
  return textOn === 'light' ? TEXT_LIGHT : TEXT_DARK;
}

function roleLabel(role) {
  switch (role) {
    case 'primary':
      return 'Primary';
    case 'secondary':
      return 'Secondary';
    case 'accent':
      return 'Accent';
    case 'neutral':
      return 'Neutral';
    case 'background':
      return 'Background';
    default:
      return role;
  }
}

function fillRect(png, x, y, width, height, rgb) {
  for (let iy = y; iy < y + height; iy += 1) {
    for (let ix = x; ix < x + width; ix += 1) {
      if (ix < 0 || iy < 0 || ix >= png.width || iy >= png.height) continue;
      const idx = (png.width * iy + ix) << 2;
      png.data[idx] = rgb[0];
      png.data[idx + 1] = rgb[1];
      png.data[idx + 2] = rgb[2];
      png.data[idx + 3] = 255;
    }
  }
}

function hexToRgb(hex) {
  const color = chroma(hex);
  return color.rgb().map((value) => Math.round(value));
}

function drawPixelText(png, text, startX, startY, rgb, scale = 3) {
  const chars = text.toUpperCase().split('');
  let x = startX;
  let y = startY;
  chars.forEach((char) => {
    if (char === '\n') {
      y += FONT_HEIGHT * scale + scale;
      x = startX;
      return;
    }
    const glyph = PIXEL_FONT[char] ?? PIXEL_FONT[' '];
    glyph.forEach((row, rowIndex) => {
      row.split('').forEach((pixel, colIndex) => {
        if (pixel === '1') {
          fillRect(png, x + colIndex * scale, y + rowIndex * scale, scale, scale, rgb);
        }
      });
    });
    x += (FONT_WIDTH + 1) * scale;
  });
}

async function packPng(png) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    png
      .pack()
      .on('data', (chunk) => chunks.push(chunk))
      .on('end', () => resolve(Buffer.concat(chunks)))
      .on('error', reject);
  });
}

const FONT_WIDTH = 5;
const FONT_HEIGHT = 7;

const PIXEL_FONT = {
  ' ': ['00000', '00000', '00000', '00000', '00000', '00000', '00000'],
  A: ['01110', '10001', '10001', '11111', '10001', '10001', '10001'],
  B: ['11110', '10001', '10001', '11110', '10001', '10001', '11110'],
  C: ['01111', '10000', '10000', '10000', '10000', '10000', '01111'],
  D: ['11110', '10001', '10001', '10001', '10001', '10001', '11110'],
  E: ['11111', '10000', '10000', '11110', '10000', '10000', '11111'],
  F: ['11111', '10000', '10000', '11110', '10000', '10000', '10000'],
  G: ['01111', '10000', '10000', '10011', '10001', '10001', '01111'],
  H: ['10001', '10001', '10001', '11111', '10001', '10001', '10001'],
  I: ['01110', '00100', '00100', '00100', '00100', '00100', '01110'],
  J: ['00111', '00010', '00010', '00010', '10010', '10010', '01100'],
  K: ['10001', '10010', '10100', '11000', '10100', '10010', '10001'],
  L: ['10000', '10000', '10000', '10000', '10000', '10000', '11111'],
  M: ['10001', '11011', '10101', '10101', '10001', '10001', '10001'],
  N: ['10001', '10001', '11001', '10101', '10011', '10001', '10001'],
  O: ['01110', '10001', '10001', '10001', '10001', '10001', '01110'],
  P: ['11110', '10001', '10001', '11110', '10000', '10000', '10000'],
  Q: ['01110', '10001', '10001', '10001', '10001', '10010', '01101'],
  R: ['11110', '10001', '10001', '11110', '10100', '10010', '10001'],
  S: ['01111', '10000', '10000', '01110', '00001', '00001', '11110'],
  T: ['11111', '00100', '00100', '00100', '00100', '00100', '00100'],
  U: ['10001', '10001', '10001', '10001', '10001', '10001', '01110'],
  V: ['10001', '10001', '10001', '10001', '01010', '01010', '00100'],
  W: ['10001', '10001', '10001', '10101', '10101', '11011', '10001'],
  X: ['10001', '01010', '00100', '00100', '01010', '10001', '10001'],
  Y: ['10001', '01010', '00100', '00100', '00100', '00100', '00100'],
  Z: ['11111', '00001', '00010', '00100', '01000', '10000', '11111'],
  '0': ['01110', '10001', '10011', '10101', '11001', '10001', '01110'],
  '1': ['00100', '01100', '00100', '00100', '00100', '00100', '01110'],
  '2': ['01110', '10001', '00001', '00010', '00100', '01000', '11111'],
  '3': ['11110', '00001', '00001', '01110', '00001', '00001', '11110'],
  '4': ['00010', '00110', '01010', '10010', '11111', '00010', '00010'],
  '5': ['11111', '10000', '10000', '11110', '00001', '00001', '11110'],
  '6': ['01110', '10000', '10000', '11110', '10001', '10001', '01110'],
  '7': ['11111', '00001', '00010', '00100', '01000', '01000', '01000'],
  '8': ['01110', '10001', '10001', '01110', '10001', '10001', '01110'],
  '9': ['01110', '10001', '10001', '01111', '00001', '00001', '01110'],
  '#': ['00100', '00100', '11111', '00100', '11111', '00100', '00100']
};
